# 一、动态创建和静态创建

在使用 FreeRTOS 创建任务、队列、信号量等对象的时，一般都提供了两种方法：

**动态方法创建**：**自动地从FreeRTOS管理的内存堆中申请创建对象所需的内存**，并且在对象删除后，可将 这块内存释放回FreeRTOS管理的内存堆 

**静态方法创建**：**需用户提供内存空间，并且使用静态方式占用的内存空间一般固定下来了**，即使任 务、队列等被删除后，这些被占用的内存空间也没有释放



# 二、为什么不使用malloc()和free()

**在一般的实时嵌入式系统中，由于实时性的要求，很少使用虚拟内存机制**。

**所有的内存都需要用户参与分配，直接操作物理内存，所分配的内存不能超过系统的物理内存，所有的系统堆栈的管理，都由用户自己管理。**

在嵌入式实时操作系统中，对内存分配时间要求更为严格，**即分配内存的时间必须确定**。

**一般内存管理算法是根据需要存储的数据的长度在内存中去寻找一个与这段数据相适应的空闲内存块，然后将数据存储在里面**。

而寻找这样一个空闲内存块所耗费的时间是不确定的。**实时系统必须要保证内存块的分配过程在可预测的确定时间内完成，**否则实时任务对外部事件的响应也将变得不可确定。

**在嵌入式系统中，内存是有限的，在分配过程中会不断被分配以及不断被释放，整个系统内存区域会产生越来越多的碎片，导致地址不连续，不能够作为一整个大的内存分配出去，容易导致系统瘫痪，所以需要一个良好的内存分配算法来避免这种情况发生。**

其实这都是因为malloc和free的设计上考虑，它们是基于列表分配算法的，**该算法将内存池组织到单个链表中的连续位置，分配器管理该链表，每次分配实际上就是寻找空闲位置。**

在嵌入式实时操作系统中，**调用malloc()和free()其实是比较危险的，其主要原因有如下：**

- 这些函数在小型嵌入式系统中并不总是可用的，**小型嵌入式设备中的 RAM 不足**
- 其实现所需要的依赖太多，占用大部分的代码空间
- 几乎都不安全
- 可能产生碎片
- 会使得链接器配置变得复杂
- 如果**允许堆空间的生长方向覆盖其他变量占据的内存，它们会成为 debug 的灾难**

不同的嵌入式系统具有不同的内存配置和时间要求。所以单一的内存分配算法只可能适合部分应用程序。FreeRTOS 将内存分配作为可移植层面，有针对性的提供了不同的内存分配管理算法。RTOS提供了五种内存管理算法，分别是**heap_1.c、heap_2.c、heap_3.c、heap_4.c、heap_5.c**，其源文件位于FreeRTOS\Source\portable\MemMang 路径下，选择一个添加即可。



# 三、FreeRTOS内存管理算法



## 1.heap_1内存管理算法

**heap_1只实现了pvPortMalloc，没有实现vPortFree。也就是说，它只能申请内存，无法释放内存**。如果你的工程，创建好的任务、队列、信号量等都不需要被删除，那么可以使用heap_1内存管理算法，**heap_1的实现最为简单，管理的内存堆是一个数组，在申请内存的时候，heap_1内存管理算法只是简单地从数组中分出合适大小的内存**，内存堆数组的定义如下所示：

```c
/* 定义一个大数组作为 FreeRTOS 管理的内存堆 */
static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
```

![图片描述](https://img.mukewang.com/wiki/6630bead09d77e7010920495.jpg)



## 2.heap_2内存管理算法

相比于heap_1内存管理算法， **heap_2内存管理算法使用最适应算法，并且支持释放内存**。**heap_2内存管理算法并不能将相邻的空闲内存块合并成一个大的空闲内存块，不可避免地会产生内存碎片**

**最适应算法:**假设heap有3块空闲内存（按内存块大小由小到大排序)︰5字节、25字节、50字节，**现在新创建一个任务需要申请20字节的内存：找出最小的、能满足pvPortMalloc的内存**：25字节,把它划分为20字节、5字节，返回这20字节的地址，剩下的5字节仍然是空闲状态，留给后续的pvPortMalloc使用
![图片描述](https://img.mukewang.com/wiki/6630becc09b6fd9012800513.jpg)



## 3.Heap_3内存管理算法

**Heap_3方案只是简单的封装了标准 C 库中的 malloc()和 free()函数，并且能满足常用的编译器**。重新封装后的 malloc()和 free()函数具有保护功能，**采用的封装方式是操作内存前挂起调度器、完成后再恢复调度器**。

**特点：**

- 需要链接器设置一个堆，malloc()和 free()函数由编译器提供。
- 具有不确定性。
- 很可能增大 RTOS 内核的代码大小。

在使用这种模式时，**FreeRTOSConfig.h 文件中的configTOTAL_HEAP_SIZE 宏定义不起作用**。**使用的是启动文件中设置的堆的大小**，单位为字节。

```c
void * pvPortMalloc( size_t xWantedSize )
{
    void * pvReturn;

    vTaskSuspendAll();
    {
        pvReturn = malloc( xWantedSize );
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();

    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
        {
            vApplicationMallocFailedHook();
        }
    }
    #endif

    return pvReturn;
}

void vPortFree( void * pv )
{
    if( pv != NULL )
    {
        vTaskSuspendAll();
        {
            free( pv );
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    }
}
```



## 4.heap_4内存管理算法

heap_4内存管理算法使用了**`首次适应算法`**，**也支持内存的申请与释放，并且能够将空闲且相邻的内存进行合并**，**从而减少内存碎片的现象。**

**首次适应算法**： 假设heap有3块空闲内存(按内存块地址由低到高排序)︰5字节、50字节、25字节，**现在新创建一个任务需要申请20字节的内存,找出****`第一个能满足pvPortMalloc的内存`**:50字节,把它划分为20字节、30字节;返回这20字节的地址，剩下30字节仍然是空闲状态，留给后续的pvPortMalloc使用

![图片描述](https://img.mukewang.com/wiki/6630bee40951e3ec12800519.jpg)



## 5.heap_5内存管理算法

heap_5内存管理算法是在 heap_4内存管理算法的基础上实现的，但是**heap_5内存管理算法在heap_4内存管理算法的基础上实现了管理多个非连续内存区域的能力**，**heap_5内存管理算法默认并没有定义内存堆，需要用户手动指定内存区域的信息，对其进行初始化。** 适用场景：在嵌入式系统中，那些内存的地址并不连续的场景。 **怎么指定一块内存?——使用如下结构体：**

```c
typedef struct HeapRegion{
        uint8_t *         pucStartAddress;    /* 内存区域的起始地址 */
        size_t            xSizeInBytes;       /* 内存区域的大小，单位：字节 */
}HeapRegion_t; 

HeapRegion_t结构体：用户需要指定每个内存堆区域的起始地址和内存堆大小 、将它们放
在一个HeapRegion_t 结构体类型数组中，这个数组必须用一个 NULL 指针和 0 作为结尾，
起始地址必须从小到大排列。

```

**怎么指定多块不连续内存？**

```c
/* 在内存中为内存堆分配两个内存块。
第一个内存块大小为 0x10000 字节,起始地址为 0x80000000,
第二个内存块大小为 0xa0000 字节,起始地址为 0x90000000。
起始地址为 0x80000000 的内存块的起始地址更低,因此放到了数组的第一个位置。*/
const HeapRegion_t xHeapRegions[] = {
        { ( uint8_t * ) 0x80000000UL, 0x10000 },
        { ( uint8_t * ) 0x90000000UL, 0xa0000 },
        { NULL, 0 } /* 数组结尾 */
};

/* 向函数 vPortDefineHeapRegions()传递形参-传入数组首地址，自动判断，结束地址为0地址 */
vPortDefineHeapRegions( xHeapRegions );

```



# 四、FreeRTOS内存管理相关API函数介绍



## 1.申请内存

```c
void * pvPortMalloc( size_t xWantedSize )
参数:
xWantedSize 申请的内存大小，以字节为单位;

返回值:
返回一个指针，指向已分配大小的内存。如果申请内存失败，则返回NULL。 
```



## 2.释放内存

```c
void vPortFree( void *pv )
*pv:指针指向一个要释放内存的内存块;
```



## 3.获取当前空闲内存的大小

```c
size_t xPortGetFreeHeapSize( void );
返回值:返回当前剩余的空闲内存大小.
```

## 案例测试

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/6e4909606703414baf37dc6b6ba12f54.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b6abe1607e6a4265ab9726b41d353cda.png)	