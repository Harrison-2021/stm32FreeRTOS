# 一、任务创建与删除

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f2eb3cfc6a9840ac96bccc2651a31881.png)

## 1.xTaskCreate

```c
 typedef long BaseType_t;
 BaseType_t xTaskCreate(   TaskFunction_t pvTaskCode,
                            const char * const pcName,
                            configSTACK_DEPTH_TYPE usStackDepth,
                            void *pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t *pxCreatedTask
                          ); 



#define pdFALSE              ( ( BaseType_t ) 0 )
#define pdTRUE               ( ( BaseType_t ) 1 )

#define pdPASS               ( pdTRUE )
#define pdFAIL               ( pdFALSE )
#define errQUEUE_EMPTY       ( ( BaseType_t ) 0 )
#define errQUEUE_FULL        ( ( BaseType_t ) 0 )

/* FreeRTOS error definitions. */
#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY        ( -1 )
#define errQUEUE_BLOCKED                             ( -4 )
#define errQUEUE_YIELD                               ( -5 )
```

> **功能:**
> 创建一个新任务并将其添加到准备运行的任务列表中。<font color=green>每个任务都需要RAM来保存任务状态，并由任务用作其堆栈。</font>
> 如果使用 <font color="#fd6f01">**xTaskCreate() 创建任务，则所需的RAM将自动从FreeRTOS堆中分配。**</font>
>
> 参数:
> **@pvTaskCode    <font color=green>函数指针</font>**，任务对应的C函数,TaskFunction_t类型为 
>
> ​							`typedef void (*TaskFunction_t)( void *)`
> ​             
> **@pcName          <font color=green>任务的名称</font>**，仅用于调试目的，FreeRTOS 内部不使用。
> ​               			pcName 的长度为 configMAX_TASK_NAME_LEN。
> ​              			 #define configMAX_TASK_NAME_LEN   ( 16 )
> ​             
> @usStackDepth  每个任务都有自己的栈，usStackDepth 指定了栈的大小，单位为 word。
> ​             			   例如，如果传入100，表示栈的大小为 100 word，即 400 字节。最大值为
> ​               		     uint16_t 的最大值。
> ​                            <font color=green>**确定栈的大小并不容易，通常是根据估计来设定。即，要根据芯片flash大小来参考**</font>
> ​               
> @pvParameters  **调用 pvTaskCode 函数指针时使用的参数**：pvTaskCode(pvParameters)。
>
> @uxPriority        任务的优先级范围为 0~(configMAX_PRIORITIES – 1)。<font color=green>**数值越小，优先级越低。**</font>
>                           <font color=green>**如果传入的值过大，xTaskCreate会将其调整为(configMAX_PRIORITIES – 1)**。</font>
>                           #define configMAX_PRIORITIES    ( 56 )
>                
> @pxCreatedTask 用于保存 <font color=green>**xTaskCreate 的输出结果，即任务的句柄（task handle）**</font>。
>     		                任务会用一个结构体封装，传入结构体的地址指针
>                             如果以后需要对该任务进行操作，如修改优先级，则需要使用此句柄。
>                             如果不需要使用该句柄，可以传入 NULL。
>                
> 返回值:
> <font color=green>**成功时返回 pdPASS，失败时返回 errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY（失败原因是内存不足）**</font>。

> **官方文档地址**:https://www.freertos.org/zh-cn-cmn-s/a00106.html



举例说明:

```c
/* Task to be created. */
void vTaskCode( void * pvParameters )
{
    /* The parameter value is expected to be 1 as 1 is passed in the
    pvParameters value in the call to xTaskCreate() below.
    
    configASSERT( ( ( uint32_t ) pvParameters ) == 1 );

    for( ;; )
    {
        /* Task code goes here. */
    }
}

/* Function that creates a task. */
void vOtherFunction( void )
{
    BaseType_t xReturned;
    TaskHandle_t xHandle = NULL;

    /* Create the task, storing the handle. */
    xReturned = xTaskCreate(
                    vTaskCode,       /* Function that implements the task. */
                    "NAME",          /* Text name for the task. */
                    STACK_SIZE,      /* Stack size in words, not bytes. */
                    ( void * ) 1,    /* Parameter passed into the task. */
                    tskIDLE_PRIORITY,/* Priority at which the task is created. */
                    &xHandle );      /* Used to pass out the created task's handle. */

    if( xReturned == pdPASS )
    {
        /* The task was created.  Use the task's handle to delete the task. */
        vTaskDelete( xHandle );
    }
}
```

### 自定义代码测试

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/6b28bc58144e469da180e54118d9530f.png)

```c
#include "FreeRTOS.h"
#include "task.h"
#include "cmsis_os.h"
#include <stdio.h>
#include "usart.h"

#define TASK_STACk_SIZE 128

/* 创建的任务的句柄 */
TaskHandle_t taskHandle; // 指针类型

/* 重写fputs函数-实现printf函数
在stm32的MicroLIB库中实现的printf函数最终是通过调用fputc函数输出数据
*/
int fputc(int ch, FILE *f) {
    HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1,HAL_MAX_DELAY);
    return  EOF;
}

/* 自己创建的任务中要执行的函数 
typedef void (*TaskFunction_t)( void * );
*/
void taskFunction(void *arg) { // 要有参数-函数指针
    while(1) {
		printf("this is task1\r\n");
		osDelay(1000); // 取决于tick频率，本案例1ms
	}
}

/* 创建一个自定义的任务 */
void freertos_task_init(void) { // 要有void参数
    BaseType_t ret;
    ret = xTaskCreate(taskFunction, "task1", TASK_STACk_SIZE, NULL, 
                     osPriorityNormal, &taskHandle);
    if(ret != pdPASS) {
        printf("create freertos tesk error!\r\n");
        return;
    }
}

```

#### 延迟函数

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/5d7d2052b2b640608be2b6cbe2750009.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/295eb0b63d6c4fa99290576e48ac3e66.png)

#### 串口调试测试

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c08cae4ab9d84cbc9c3e5d04c61a8799.png)

#### printf函数实现

##### 1.Use MicroLIB

![图片描述](https://img.mukewang.com/wiki/6401c97d09c3500d07120497.jpg)



##### 2.重写fputc函数

在stm32的<font color=green>**MicroLIB库**</font>中实现的**printf函数最终是通过调用fputc函数输出数据**。

```c
#include <stdio.h>

int fputc(int ch, FILE *f)
{
      HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1,HAL_MAX_DELAY);
      return  EOF;
}

```

### 测试结果展示

- 因自定义任务优先级与默认任务优先级相同，会交替执行

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/79f1cb25add04cc8a7077d9d6b71fbc9.png)

## 2.xTaskCreateStatic

<font color="#fd6f01">**与xTaskCreate不同的是，需要应用程序指定任务分配的内存地址，而不是由堆区自动分配内存**</font>

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d9723684ff214bfba8aea400d039f75e.png)

```c
TaskHandle_t xTaskCreateStatic(  TaskFunction_t pxTaskCode,
                                 const char * const pcName,
                                 const uint32_t ulStackDepth,
                                 void * const pvParameters,
                                 UBaseType_t uxPriority,
                                 StackType_t * const puxStackBuffer,//分配栈区内存的起始地址
                                 StaticTask_t * const pxTaskBuffer );//TCB内存
  
功能:
创建一个新任务并将其添加到准备运行的任务列表中。每个任务都需要RAM来保存任务状态，并由任务用作其堆栈。
如果使用 xTaskCreateStatic() 创建任务，则 RAM 由应用程序编写者提供，这会产生更多的参数，但允许在
编译时静态分配RAM。

参数:
@pvTaskCode    函数指针，任务对应的C函数,TaskFunction_t类型为
               typedef void (*TaskFunction_t)( void *)
             
@pcName        任务的名称，仅用于调试目的，FreeRTOS 内部不使用。
               pcName 的长度为 configMAX_TASK_NAME_LEN。
               #define configMAX_TASK_NAME_LEN   ( 16 )
             
@usStackDepth  指定了栈的大小，任务栈大小，以堆栈类型（StackType_t）为单位计算

               
@pvParameters  调用 pvTaskCode 函数指针时使用的参数：pvTaskCode(pvParameters)。

@uxPriority    任务的优先级范围为 0~(configMAX_PRIORITIES – 1)。数值越小，优先级越低。
               如果传入的值过大，xTaskCreate会将其调整为(configMAX_PRIORITIES – 1)。
               #define configMAX_PRIORITIES    ( 56 )
               
@puxStackBuffer 必须指向至少具有 ulStackDepth 索引的 StackType_t 数组），该数组用作任务的堆栈，
                因此必须是永久性的。
@pxTaskBuffer   必须指向StaticTask_t类型的变量。该变量用于保存新任务的数据结构体 (TCB) ，
                因此必须是持久的
               
返回值:
如果 puxStackBuffer 和 pxTaskBuffer 均不为 NULL，则创建任务，并返回任务的句柄。
如果 puxStackBuffer 或 pxTaskBuffer 都为NULL，则不会创建任务，并返回 NULL。       
```

案例代码:

```c
/* Dimensions of the buffer that the task being created will use as its stack.
    NOTE:  This is the number of words the stack will hold, not the number of
    bytes.  For example, if each stack item is 32-bits, and this is set to 100,
    then 400 bytes (100 * 32-bits) will be allocated. */
    #define STACK_SIZE 200

    /* Structure that will hold the TCB of the task being created. */
    StaticTask_t xTaskBuffer;

    /* Buffer that the task being created will use as its stack.  Note this is
    an array of StackType_t variables.  The size of StackType_t is dependent on
    the RTOS port. */
    StackType_t xStack[ STACK_SIZE ]; // 必须是全局的数组

    /* Function that implements the task being created. */
    void vTaskCode( void * pvParameters )
    {
        /* The parameter value is expected to be 1 as 1 is passed in the
        pvParameters value in the call to xTaskCreateStatic(). */
        configASSERT( ( uint32_t ) pvParameters == 1UL );

        for( ;; )
        {
            /* Task code goes here. */
        }
    }

    /* Function that creates a task. */
    void vOtherFunction( void )
    {
        TaskHandle_t xHandle = NULL;

        /* Create the task without using any dynamic memory allocation. */
        xHandle = xTaskCreateStatic(
                      vTaskCode,       /* Function that implements the task. */
                      "NAME",          /* Text name for the task. */
                      STACK_SIZE,      /* Number of indexes in the xStack array. */
                      ( void * ) 1,    /* Parameter passed into the task. */
                      tskIDLE_PRIORITY,/* Priority at which the task is created. */
                      xStack,          /* Array to use as the task's stack. */
                      &xTaskBuffer );  /* Variable to hold the task's data structure. */
     
      /* puxStackBuffer and pxTaskBuffer were not NULL, so the task will have
        been created, and xHandle will be the task's handle.  Use the handle
        to suspend the task. */
        vTaskSuspend( xHandle );
    }
```

### 自定义代码测试

```c
#include "FreeRTOS.h"
#include "task.h"
#include "cmsis_os.h"
#include <stdio.h>
#include "usart.h"

#define TASK_STACk_SIZE 128

/* 创建的任务的句柄 */
osThreadId_t taskHandle; // 指针类型
/* 任务分配的栈内存地址 */
StackType_t stackBuf[TASK_STACk_SIZE];
/* TCB内存地址 */
StaticTask_t staticTCBBuf;

/* 重写fputs函数-实现printf函数
在stm32的MicroLIB库中实现的printf函数最终是通过调用fputc函数输出数据
*/
int fputc(int ch, FILE *f) {
    HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1,HAL_MAX_DELAY);
    return  EOF;
}

/* 自己创建的任务中要执行的函数 
typedef void (*TaskFunction_t)( void * );
*/
void taskFunction(void *arg) { // 要有参数-函数指针
    while(1) {
		printf("this is task1\r\n");
		osDelay(1000); // 取决于tick频率，本案例1ms
	}
}

void taskFunctionStatic(void *arg) { // 要有参数-函数指针
    while(1) {
		printf("this is task_staic\r\n");
		osDelay(1000); // 取决于tick频率，本案例1ms
	}
}

/* 创建一个自定义的任务 */
void freertos_task_init(void) { // 要有void参数
    BaseType_t ret;
    TaskHandle_t xHandle;
    /* 任务自动在堆区分配内存-xTaskCreate */
    ret = xTaskCreate(taskFunction, "task1", TASK_STACk_SIZE, NULL, 
                     osPriorityNormal, &taskHandle);
    if(ret != pdPASS) {
        printf("create freertos tesk error!\r\n");
        return;
    }
    /* 任务手动分配内存 */
    xHandle = xTaskCreateStatic(taskFunctionStatic,"task_staic",TASK_STACk_SIZE,NULL,
                                osPriorityNormal,stackBuf,&staticTCBBuf);
    if(!xHandle) {
        printf("creat freertos test_static error!\r\n");
        return;
    }
}

```

### 测试结果展示

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/88028bcccb7549c49ea13247861e2ce8.png)

## 3.任务创建过程分析



### (1)任务控制块/句柄

```c
/*
 * Task control block.  A task control block (TCB) is allocated for each task,
 * and stores task state information, including a pointer to the task's context
 * (the task's run time environment, including register values)
 */
typedef struct tskTaskControlBlock
{
     volatile StackType_t *pxTopOfStack;           //任务栈顶
     ListItem_t   xStateListItem;                  //用于将任务链接到就绪、阻塞或挂起状态的列表中
     ListItem_t   xEventListItem;                  //用于将任务链接到事件列表中
     UBaseType_t  uxPriority;                      //任务优先级
     StackType_t  *pxStack;                        //指向任务栈底的指针，即栈的起始地址
     char pcTaskName[ configMAX_TASK_NAME_LEN ];   //任务名称
     ....
} tskTCB;

typedef tskTCB TCB_t;

#define portSTACK_TYPE    uint32_t
typedef portSTACK_TYPE    StackType_t;
typedef unsigned long     UBaseType_t;
```

在 `struct tskTaskControlBlock` 中，`pxTopOfStack` 和 `pxStack` 是两个不同的成员，它们在任务的栈管理中扮演着不同的角色：

#### 1.pxTopOfStack

1. 这个指针始终指向任务栈的顶部（top）。
2. 它是任务上下文切换的关键部分，因为它表示当前任务栈帧（stack frame）的顶部位置。
3. 在任务切换时，操作系统会更新这个指针，以确保它可以正确地保存和恢复任务的上下文。
4. **当任务被调度执行时，新的函数调用和局部变量会被推入（pushed to）栈中，`pxTopOfStack` 指针会相应地向下移动**。

#### 2.pxStack

1. 这个指针指向任务栈的底部（base），即栈的起始地址。
2. **在任务创建时，\**\**`pxStack`** **被初始化为指向分配给该任务的栈内存的开始位置**。
3. 它通常不用于日常的任务调度，但在任务创建和删除时可能会用到，例如在任务被删除时，需要知道栈的起始地址来正确释放内存。

简而言之，<font color=green>**`pxTopOfStack`** **是一个动态更新的指针，用于跟踪当前任务栈的使用情况，而** **`pxStack`** **是一个静态的指针，用于标识任务栈的起始位置**。</font>这两个指针共同定义了任务栈的范围，`pxStack` 指向栈底，`pxTopOfStack` 指向栈顶。在任务的生命周期中，`pxTopOfStack` 会随着栈的使用而变化，而 `pxStack` 保持不变。



### (2)创建过程分析

```c
BaseType_t xTaskCreate(TaskFunction_t pxTaskCode,
                       const char * const pcName,
                       const uint16_t usStackDepth,
                       void * const pvParameters,
                       UBaseType_t uxPriority,
                       TaskHandle_t * const pxCreatedTask )
{
    TCB_t *pxNewTCB;
    BaseType_t xReturn;
    StackType_t *pxStack;
 
    /* 任务栈内存分配*/
    pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) *
                                                   sizeof( StackType_t ) ) );
    if( pxStack != NULL ){
          /* 任务控制块内存分配 */
          pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); 
          if( pxNewTCB != NULL ){
                 /* 赋值栈地址 */
                 pxNewTCB->pxStack = pxStack;
           }else{
                   /* 释放栈空间 */
                   vPortFree( pxStack );
           }
     }else{
            pxNewTCB = NULL;
     }
 
     if( pxNewTCB != NULL ){
           //以设置任务控制块（TCB）中的各种参数，并准备任务的堆栈和上下文，以便它可以被调度器执行
           prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth,
                                 pvParameters, uxPriority, 
                                 pxCreatedTask, pxNewTCB, NULL );
           //把任务添加到就绪列表中
           prvAddNewTaskToReadyList( pxNewTCB );
           xReturn = pdPASS;
     }else{
           xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     }
 
     return xReturn;
}



static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,
                                  const char * const pcName,
                                  const uint32_t ulStackDepth,
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t *pxNewTCB,
                                  const MemoryRegion_t * const xRegions ) 
{
      StackType_t *pxTopOfStack;
      UBaseType_t x;
     
      ...
      //赋值任务优先级
      pxNewTCB->uxPriority = uxPriority;
 
      //状态表、事件表初始化
      vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
      vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 #define vListInitialiseItem( pxItem ) { (pxItem)->pxNext = NULL; \
                                         (pxItem)->pxPrevious = NULL; }
 
       /*任务控制块链接到状态表中*/
       listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    #define listSET_LIST_ITEM_OWNER( pxItem, xValue ) (pxItem)->pxContainer = (xValue)
 
       /*任务控制块连接到事件表中 */
       listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ),
                     ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); 
 #define listSET_LIST_ITEM_VALUE( pxItem, xValue ) (pxItem)->uxValue = (UBaseType_t)(xValue)
       ...
 
       if( ( void * ) pxCreatedTask != NULL )
       {
             /*赋值任务的句柄，即任务控制块*/
             *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
       }
}


static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
        /* Ensure interrupts don't access the task lists while the lists are being
        updated. */
        taskENTER_CRITICAL();
        {
                uxCurrentNumberOfTasks++;
                if( pxCurrentTCB == NULL )
                {
                        /* There are no other tasks, or all the other tasks are in
                        the suspended state - make this the current task. */
                        pxCurrentTCB = pxNewTCB;
                        ...
                }
               ...

                prvAddTaskToReadyList( pxNewTCB );
        }
        
        taskEXIT_CRITICAL();
}

/*
 * Place the task represented by pxTCB into the appropriate ready list for
 * the task.  It is inserted at the end of the list.
    根据优先级插入-找到对应的链表，优先级放在数组中，类似哈希表的实现（链地址法）-数组+链表
 */
#define prvAddTaskToReadyList( pxTCB ) \
     vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), \
                     &( ( pxTCB )->xStateListItem ) );
                     
/* Lists for ready and blocked tasks. --------------------*/
PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ] = {0};    
/*< Prioritised ready tasks. */
#define configMAX_PRIORITIES  ( 56 )
```

#### 流程总结

- 分配任务控制块内存空间，分配任务堆栈空间
- 初始化任务控制块，初始化任务堆栈
- 添加任务到就绪列表中



## 4.vTaskList

### 函数定义

```c
void vTaskList( char *pcWriteBuffer );
功能:
    显示任务详细信息 
 
参数:
    @pcWriteBuffer 保存任务状态信息表的存储区，须足够大

pcWriteBuffe表中信息:
Name     ：创建任务的时候给任务分配的名字
State    ：任务的状态信息，X：运行态，B：阻塞态，R：就绪态，S：挂起态，D：删除态
Priority ：任务优先级
Stack    ：任务堆栈的“高水位线”，就是堆栈历史最小剩余值
Num      ：任务编号，这个编号是唯一的；当多个任务使用同一个任务名的时候；可以通过编号来区分

```

![图片描述](https://img.mukewang.com/wiki/660a265009d3662006260305.jpg)

### 配置

注意:
```apl
在使用vTaskList前需要在FreeRTOSConfig.h文件中打开如下宏
#define configUSE_TRACE_FACILITY                 1 
#define configGENERATE_RUN_TIME_STATS            1
#define configUSE_STATS_FORMATTING_FUNCTIONS     1 
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/3ce8aa1e5619477db2123298907c7340.png)

### 案例测试

```c
#include "FreeRTOS.h"
#include "task.h"
#include "cmsis_os.h"
#include <stdio.h>
#include "usart.h"

#define TASK_STACk_SIZE 128

/* 创建的任务的句柄 */
osThreadId_t taskHandle;      // 指针类型
osThreadId_t taskHandlePrint; // 指针类型
/* 任务分配的栈内存地址 */
StackType_t stackBuf[TASK_STACk_SIZE];
/* TCB内存地址 */
StaticTask_t staticTCBBuf;

/* 重写fputs函数-实现printf函数
在stm32的MicroLIB库中实现的printf函数最终是通过调用fputc函数输出数据
*/
int fputc(int ch, FILE *f) {
    HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1,HAL_MAX_DELAY);
    return  EOF;
}

/* 自己创建的任务中要执行的函数 
typedef void (*TaskFunction_t)( void * );
*/
void taskFunction(void *arg) { // 要有参数-函数指针
    while(1) {
		printf("this is task1\r\n");
		osDelay(1000); // 取决于tick频率，本案例1ms
	}
}

void taskFunctionStatic(void *arg) { // 要有参数-函数指针
    while(1) {
		printf("this is task_staic\r\n");
		osDelay(1000); // 取决于tick频率，本案例1ms
	}
}

void showTaskFunction(void *arg) { // 要有参数-函数指针
    //static char pcWriteBuffer[200] = {0}; --stack:62
    char pcWriteBuffer[200];              //--stack:12
    while(1) {
		vTaskList(pcWriteBuffer);
        printf("-----------------------------------------\r\n");
        printf("Name\t\tState\tPriority  Stack  Num\r\n");
        printf("%s\r\n",pcWriteBuffer);
        osDelay(1000); // 取决于tick频率，本案例1ms
	}
}

/* 创建一个自定义的任务 */
void freertos_task_init(void) { // 要有void参数
    BaseType_t ret;
    TaskHandle_t xHandle;
    /* 1.任务自动在堆区分配内存-xTaskCreate */
    ret = xTaskCreate(taskFunction, "task1", TASK_STACk_SIZE, NULL, 
                     osPriorityNormal, &taskHandle);
    if(ret != pdPASS) {
        printf("create freertos tesk error!\r\n");
        return;
    }
    /* 2.任务手动分配内存 */
    xHandle = xTaskCreateStatic(taskFunctionStatic,"task_staic",TASK_STACk_SIZE,NULL,
                                osPriorityNormal,stackBuf,&staticTCBBuf);
    if(!xHandle) {
        printf("creat freertos test_static error!\r\n");
        return;
    }

    /* 3.创建进程打印任务详细信息- vTaskList*/
    ret = xTaskCreate(showTaskFunction, "task_print", TASK_STACk_SIZE, NULL, 
                     osPriorityNormal, &taskHandlePrint);
    if(ret != pdPASS) {
        printf("create freertos task_print error!\r\n");
        return;
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ea1ad67d1fe74a55962d85fd73874dc1.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/2f02160810ab470ab44cd552664806f4.png)

## 5.vTaskDelete

```c
void vTaskDelete( TaskHandle_t xTaskToDelete );
功能:
删除任务

参数:
@xTaskToDelete 任务句柄

任务退出：vTaskDelete(NULL)       // 在任务函数中调用，表示退出当前任务
删除任务：vTaskDelete(xHandle)    // 退出指定的句柄任务
```

### 案例测试

```c
void taskFunction(void *arg) { // 要有参数-函数指针
    int i;
    for(i = 0; i < 3; i++) {
		printf("this is task1\r\n");
		osDelay(1000); // 取决于tick频率，本案例1ms
	}
    // 执行3秒后删除任务
    vTaskDelete(taskHandleState); // 先删除别的任务
    vTaskDelete(NULL);            // 删除自己任务
}

```



![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/80517f67b6174d968104b01d0b350cd4.png)

## 6.任务删除过程分析

1.从就绪列表中移除

2.从事件列表中移除

3.删除任务：释放任务控制块、释放任务堆栈内存

- 删除非自己任务：直接删除
- 删除自己任务：    
  - 添加到等待删除任务列表中，放入空闲任务中，让空闲任务进行删除
  - 放弃CPU执行权

4.开始新的任务调度

```c
void vTaskDelete( TaskHandle_t xTaskToDelete )
{
    TCB_t *pxTCB;
 
    //进入临界段
    //当任务执行到这个宏时，它会禁用中断，从而阻止任何中断处理程序的执行，也阻止其他任务的切换
    taskENTER_CRITICAL();
    {
        pxTCB = prvGetTCBFromHandle( xTaskToDelete );
        /*从就绪列表中移除*/
        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
              /*从事件列表中移除*/
              if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL ){
                   ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
               }
                
        //如果是删除当前任务
        if( pxTCB == pxCurrentTCB ){
                /* 不能在这里删除，在空闲任务中删除，把任务添加到等待删除的任务列表中 */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
                /* 给空闲任务一个标记 */
                 ++uxDeletedTasksWaitingCleanUp;
                 /* 钩子函数----用户自己实现 */
                  portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
          }else //不是当前任务
          {
             //直接删除任务控制块
             --uxCurrentNumberOfTasks;
             prvDeleteTCB( pxTCB );
          }
     }
     //退出临界段
     //当任务执行到这个宏时，它会恢复中断，允许中断处理程序执行，也允许任务切换
     taskEXIT_CRITICAL()；
      
      /* 判断调度器是否开启 */
      if( xSchedulerRunning != pdFALSE ){
        //如果是删除任务本身，马上进行任务调度（释放CPU使用权）
        if( pxTCB == pxCurrentTCB ){
                        configASSERT( uxSchedulerSuspended == 0 );
                        portYIELD_WITHIN_API();
          }
       }
}

总结:
A.从就绪列表中删除
B.从事件列表中删除
C.释放任务控制块、释放任务堆栈内存
D.开始任务调度
```



# 二、任务挂起和恢复



## 1.vTaskSuspend

```c
void vTaskSuspend( TaskHandle_t xTaskToSuspend );
参数：
xTaskToSuspend 被挂起的任务句柄。传递空句柄将导致调用任务被暂停。
```

举例说明:

```c
 void vAFunction( void )
 {
     TaskHandle_t xHandle;

     // Create a task, storing the handle.
     xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
     // ...
     // Use the handle to suspend the created task.
     vTaskSuspend( xHandle );
     // ...
     // The created task will not run during this period, unless
     // another task calls vTaskResume( xHandle ).
     //...

     // Suspend ourselves.
     vTaskSuspend( NULL );

     // We cannot get here unless another task calls vTaskResume
     // with our handle as the parameter.
 }
```

### 案例测试

```c
void taskFunction(void *arg) { // 要有参数-函数指针
    int i;
    for(i = 0; i < 3; i++) {
		printf("this is task1\r\n");
		osDelay(1000); // 取决于tick频率，本案例1ms
	}
    // 执行3秒后删除任务
    //vTaskDelete(taskHandleState); // 先删除别的任务
    // 执行3秒后挂起任务
    vTaskSuspend(taskHandleState);
    vTaskDelete(NULL);            // 删除自己任务
}
```

**State    ：任务的状态信息，X：运行态，B：阻塞态，R：就绪态，S：挂起态，D：删除态**

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a1614d66f5e94ad69e36565109f7698f.png)

## 2.任务挂起过程分析

<font color=green>**任务挂起业务流程：**</font>
a.从就绪列表中删除
b.从事件列表中删除
c.添加任务到挂起列表中
d.开始任务调度

```c
void vTaskSuspend( TaskHandle_t xTaskToSuspend )
{
     TCB_t *pxTCB; 

     taskENTER_CRITICAL();
     {
         /* 获取任务控制块 */
         pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
          /*从就绪列表中移除*/
          if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 ){
             /*从事件列表中移除*/
             if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL ){
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
              }
 
            //把任务添加到挂起列表中
            //PRIVILEGED_DATA static List_t xSuspendedTaskList = {0}; 
            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
        }
      //退出临界段
      taskEXIT_CRITICAL();
  
      if( pxTCB == pxCurrentTCB )
      {
                if( xSchedulerRunning != pdFALSE )//调度器开启
                {
                        /*如果是当前任务，立即开启任务调度，释放CPU */
                        configASSERT( uxSchedulerSuspended == 0 );
                        portYIELD_WITHIN_API();
                }
                else
                {
                    /*如果调度器没开启，读取当前任务挂起列表的长度
                      长度相同代表:已经把所有任务挂起
            *        */
                     if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == 
                             uxCurrentNumberOfTasks )
                        {
                            /* 那么把当前任务的控制块赋值未NULL，不让任务控制块再使用 */
                            pxCurrentTCB = NULL;
                        }  //如果还有任务在就绪列表
                        else 
                        {
                            //任务上下文切换
                            //即再就绪列表中找到优先级最高的任务，进行调度
                            vTaskSwitchContext();
                        }
               }
       }
}



```



## 3.vTaskResume

```c
void vTaskResume( TaskHandle_t xTaskToResume );
参数：
    xTaskToResume 要恢复的任务句柄。
```

举例说明:

```c
 void vAFunction( void )
 {
     TaskHandle_t xHandle;
     
     // Create a task, storing the handle.
     xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
     // ...
     // Use the handle to suspend the created task.
     vTaskSuspend( xHandle );


     // ...
     // The created task will not run during this period, unless
     // another task calls vTaskResume( xHandle ).
     //...

 }
```

### 案例测试

```c
void taskFunctionStatic(void *arg) { // 要有参数-函数指针
    // 挂起当前任务
    printf("start running task_static\r\n");
    vTaskSuspend(NULL);
    while(1) {
		printf("this is task_staic\r\n");
		osDelay(1000); // 取决于tick频率，本案例1ms
	}
}

void taskFunction(void *arg) { // 要有参数-函数指针
    int i;
    for(i = 0; i < 3; i++) {
		printf("this is task1\r\n");
		osDelay(1000); // 取决于tick频率，本案例1ms
	}
    // 执行3秒后删除任务
    //vTaskDelete(taskHandleState); // 先删除别的任务
    // 执行3秒后挂起任务
    //vTaskSuspend(taskHandleState);
    // 执行3秒后恢复任务
    vTaskResume(taskHandleState);
    vTaskDelete(NULL);            // 删除自己任务
}

```



![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f0833c552c4640468540f17e7c0c15c9.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a7945cc175b243e8a0ffe6e6aec231b2.png)

## 4.任务恢复过程分析

<font color="#fd6f01">**任务恢复业务流程：**</font>
a.从挂起列表中删除
b.添加任务到就绪列表
c.开启任务调度

```c
void vTaskResume( TaskHandle_t xTaskToResume )
{
    // 获取需要恢复的任务控制块
    TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    
    // 参数检查
    configASSERT( xTaskToResume );
    
    // 指针不为空且不是当前任务控制块
    // 既然要使用任务控制块肯定不为空
    // 既然要恢复，肯定不能当前的执行任务
    if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) ){
        // 进入临界段
        taskENTER_CRITICAL();
        {
            // 判断任务是否已经挂起，必须挂起才能恢复
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE ){
                
                // 从挂起列表中移除
                ( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
                
                // 添加任务到就绪列表
                prvAddTaskToReadyList( pxTCB );
                
                // 判断要恢复的任务，是否大于当前任务优先级
                // 前提条件：已经使能了抢占式调度器
                if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority ){
                    // 释放CPU的使用权，开始内核调度
                    taskYIELD_IF_USING_PREEMPTION();
                }
            }
        }
        // 退出临界段
        taskEXIT_CRITICAL();
    }
}

```



# 三、任务状态转换

**在FreeRTOS中，每个任务都有一个状态，表示当前任务的情况**。FreeRTOS使用一些特定枚举来表示不同的任务状态:

```c
/* Task states returned by eTaskGetState. */
typedef enum
{
        //表示任务正在运行
        eRunning = 0,   /* A task is querying the state of itself, so must be running. */
        
        //表示任务处于就绪状态，等待调度器将其调度执行
        eReady,         /* The task being queried is in a read or pending ready list. */
        
        //表示任务处于阻塞状态，即等待某些事件的发生，例如等待信号量、消息队列、定时器超时等。
        eBlocked,       /* The task being queried is in the Blocked state. */
        
        //表示任务处于暂停状态，即该任务已经被暂停，不参与调度，但它的状态和资源保留，
        //能够在需要时恢复运行。
        eSuspended,     /* The task being queried is in the Suspended state, 
                           or is in the Blocked state with an infinite time out. */
        
        //表示任务已被删除，对应的控制块和栈空间还没被释放掉。
        eDeleted,       /* The task being queried has been deleted, but its TCB has not 
                           yet been freed. */
        
        eInvalid        /* Used as an 'invalid state' value. */
} eTaskState;
```

任务状态之间的转换是由FreeRTOS内核自动管理的。任务常常在下列几种情况下会发生状态变化：

- <font color=green>**创建任务时，任务状态由"未开始"变为"就绪"。**</font>
- <font color="#fd6f01">**调度器根据任务优先级选取该任务并将其状态变为"运行中"。**</font>
- <font color=green>**任务等待某个事件（如信号量）时，任务状态变为"阻塞"。**</font>
- <font color=red>任务等待其他任务释放资源时，任务状态可能会转变为"挂起"。</font>
- 任务自己调用删除函数删除自己时，任务状态变为"已删除"。

![图片描述](https://img.mukewang.com/wiki/660a266f0911aa3505750716.jpg)

```c
A.运行态
  正在执行的任务，该任务就处于运行态，如果使用的是单核处理器的话那么不管在任何时刻永远都只有一个任务处
  于运行态

B.就绪态
  处于就绪态的任务是那些已经准备就绪(这些任务没有被阻塞或者挂起)，可以运行的任务，但是处于就绪态的任务
  还没有运行，因为有一个同优先级或者更高优先级的任务正在运行！

C.阻塞态
  如果一个任务因延时(调用了函数 vTaskDelay())或等待外部事件发生，那么这个任务就处于阻塞态。任务进入
  阻塞态会有一个超时时间，当超过这个超时时间 任务就会退出阻塞态。

D.挂起态
  任务进入挂起态以后也不能被调度器调用进入运行态，但是进入挂起态的任务 没有超时时间。任务进入和退出
  挂起态通过调用函数 vTaskSuspend() 和 xTaskResume()
```



# 四、任务调度



## 1.什么是任务调度

调度器就是使用相关的调度算法来决定当前需要执行的哪个任务。FreeRTOS中开启任务调度的函数是 **vTaskStartScheduler()** ，但在 CubeMX 中被封装为**osKernelStart()** 。



## 2.任务调度的规则



### (1)抢占式调度

抢占式调度:高优先级抢占低优先级任务，**系统永远执行最高优先级的任务**

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a2eb034b0c7a4814963f118e22b2e4db.png)

```c
举例：
Task 1：和女朋友一起玩游戏
Task 2：和老妈一起吃饭
Task 3：和女朋友一起逛街

总结：
a.高优先级任务，优先执行；
b.高优先级任务不停止，低优先级任务无法执行； 
c.被抢占的任务将会进入就绪态
```



### (2)时间片调度

**主要针对优先级相同的任务，当多个任务的优先级相同时， 任务调度器会在<font color="#fd6f01">每一次系统时钟节拍到的时候切换任务</font>**。**同等优先级任务轮流地享有相同的 CPU 时间(可设置)， 叫时间片**，

**<font color="#fd6f01">在FreeRTOS中，一个时间片就等于SysTick 中断周期。</font>**

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/15ecf53a9e254869967430719f24f37f.png)

```c
理解：3个朋友找你打篮球（task），你先和第一个朋友打完，然后再和第二个朋友打，再和第三个朋友打，
      和第三个朋友打到一半朋友有事离开（task阻塞），继续和第一个朋友再打，依次进行。

总结：
a.同等优先级任务，轮流执行，时间片流转；
b.一个时间片大小，取决为滴答定时器中断周期；
c.注意没有用完的时间片不会再使用，下次任务 Task3 得到执行，还是按照一个时间片的时钟节拍运行

```



### (3)一些注意点

**抢占式调度和时间片轮转可以同时存在，当有高优先级任务就绪时，运行高优先级任务**；**当最高优先级的任务有好几个时，这几个任务可以以时间片轮转方式调度**

在FreeRTOS中，如果一个任务在时间片没有用完的情况下变为阻塞状态，它将释放剩余的时间片，并且调度器会利用这部分时间来执行其他任务。具体来说，以下是处理这种情况的步骤：

- **任务阻塞** 当任务执行到阻塞操作（如等待事件、信号量、队列等）时，它会停止执行并进入阻塞状态。
- **时间片回收** 一旦任务阻塞，它将不再消耗CPU时间。此时，调度器会回收该任务剩余的时间片。
- **调度其他任务** 调度器会利用回收的时间片来调度其他就绪的任务。这可能包括同一优先级的任务，也可能包括更高优先级的任务（如果存在的话）。
- **任务就绪** 当阻塞的任务等待的条件得到满足时（例如，它等待的事件或信号量被触发），它将变为就绪状态，并被放入相应的就绪列表。
- **重新调度** 调度器在下一个合适的时机（例如，当前执行的任务完成或时间片用完）会重新调度该任务，它将从上次停止执行的地方继续执行。

通过这种方式，FreeRTOS确保了系统资源的有效利用，避免了因单个任务长时间占用CPU而造成的其他任务饥饿问题。这也体现了FreeRTOS的抢占式调度特性，即任何时刻，CPU总是由当前可运行的最高优先级任务占用。**如果当前任务阻塞，调度器会立即抢占CPU，给其他就绪的任务一个运行的机会**。

使能抢占式调度和时间片轮转调度通过FreeRTOSConfig.h和FreeRTOS.h文件下的宏定义设置来实现：

```c
#define configUSE_PREEMPTION     1
#ifndef configUSE_TIME_SLICING
#define configUSE_TIME_SLICING 1
#endif

```

时间片轮询调度的时间片固定为1个时钟节拍，可以在FreeRTOSConfig.h文件下的宏定义configTICK_RATE_HZ这个宏设置，时间片的时间一到，就切换下一个同优先级的任务执行

```c
#define configTICK_RATE_HZ    ((TickType_t)1000)  //1ms

```

每 个 任 务 都 可 以 分 配 一 个 从 0~(configMAX_PRIORITIES-1) 的优先级,configMAX_PRIORITIES 在文件 FreeRTOSConfig.h 中有定义:

```c
#define configMAX_PRIORITIES    (56)

```

> 注：**优先级数字值越低表示任务的优先级越低，0为最低优先级**，当宏 configUSE_TIME_SLICING 定义为 1 的时候， 即使能了时间片轮询调度时 ， 多个任务可以共用一个优先级，数量不限。



## 3.任务调度的本质

**任务切换的本质**：**`就是CPU寄存器的切换`**。假设当由任务A切换到任务B时，主要分为两步： 

第一步：需暂停任务A的执行，并将此时任务A的寄存器（CPU寄存器的值）保存到任务堆栈，这个过程 叫做保存现场 

第二步：将任务B的各个寄存器值（被存于任务B的任务堆栈中）恢复到CPU寄存器中，这个过程叫做恢 复现场 

**对任务A保存现场，对任务B恢复现场，这个整体的过程称之为：上下文切换（可以理解为任务切换）**
![图片描述](https://img.mukewang.com/wiki/660a268809c2a25c12800622.jpg)

**任务A在运行时，CPU寄存器中是A的各个寄存器**；任务B抢占时，第一步需要将任务A寄存器保存，将CPU中任务A的各个寄存器保存到任务A的任务堆栈中，下次恢复任务A运行时，将任务A的任务堆栈中的寄存器恢复到CPU寄存器中，接着被打断的点继续运行；第二步将任务B的寄存器值恢复到CPU寄存器中；**任务切换后，CPU寄存器中就是B的各个寄存器。**

> 注意：任务切换的过程在**`PendSV中断`**服务函数(**PendSV_Handler**)里边完成。

 

## 4.PendSV中断如何触发

第一种:**滴答定时器中断调用**（判断符合条件时，触发PendSV中断） 

第二种:**执行FreeRTOS提供的相关API函数：portYIELD()** 

**本质**： **通过向中断控制和状态寄存器 ICSR（NVIC中断控制器的内部寄存器） 的bit28 写入 1 挂起 PendSV 来启动 PendSV 中断**
![图片描述](https://img.mukewang.com/wiki/660a269b092f5b4112121084.jpg)

**portYIELD()实现如下:**

```c
/* Scheduler utilities. */
#define portYIELD()                                                             \
{                                                                               \
    /* Set a PendSV to request a context switch. */                             \
    portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;                             \
                                                                                \
    /* Barriers are normally not required but do ensure the code is completely  \
    within the specified behaviour for the architecture. */                     \
    __dsb( portSY_FULL_READ_WRITE );                                            \
    __isb( portSY_FULL_READ_WRITE );                                            \
}

#define portNVIC_INT_CTRL_REG                ( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
#define portNVIC_PENDSVSET_BIT                ( 1UL << 28UL )
```



## 5.滴答定时器中断

```c
/*0xe000ed04是中断控制及状态寄存器地址，将第28位写入1将挂起PendSV启动PendSV中断*/
#define portNVIC_INT_CTRL_REG          ( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
#define portNVIC_PENDSVSET_BIT         ( 1UL << 28UL )
 
void xPortSysTickHandler( void )
{
      /* The SysTick runs at the lowest interrupt priority, so when this interrupt
        executes all interrupts must be unmasked.  There is therefore no need to
        save and then restore the interrupt mask value as its value is already
        known - therefore the slightly faster vPortRaiseBASEPRI() function is used
        in place of portSET_INTERRUPT_MASK_FROM_ISR(). */
        vPortRaiseBASEPRI();
        {
         /*Increment the RTOS tick. */
        /*xTaskIncrementTick()函数中有两种情况，需要任务切换：
         *(1)一个是阻塞超时时间到了，任务从阻塞列表中解除，挂载到就绪列表中，如果挂载到就绪列表中 
         *   的任务比当前正在执行的任务优先级高，则需任务切换；
         *(2)还有一个是时间片调度，就绪列表中存在同等优先级的任务，也需任务切换。
         */
                if( xTaskIncrementTick() != pdFALSE )
                {
                    /* A context switch is required.  Context switching is performed in
                      the PendSV interrupt.  Pend the PendSV interrupt. */
                      portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
                }
        }
        vPortClearBASEPRIFromISR();
} 
```

**PendSV中断触发，调用其处理函数:**

```c
__asm void xPortPendSVHandler( void )
{
        extern vTaskSwitchContext
        extern pxCurrentTCB

        PRESERVE8

        mrs r0, psp

        ldr        r3, =pxCurrentTCB         /* Get the location of the current TCB. */
        ldr        r2, [r3]

        subs r0, #32        /* Make space for the remaining low registers. */
        str r0, [r2]        /* Save the new top of stack. */
        stmia r0!, {r4-r7}  /* Store the low registers that are not saved automatically. */
        mov r4, r8         /* Store the high registers. */
        mov r5, r9
        mov r6, r10
        mov r7, r11
        stmia r0!, {r4-r7}

        push {r3, r14}
        cpsid i
        //通过函数vTaskSwitchContext查找下一个要运行的任务的任务控制块
        bl vTaskSwitchContext
        cpsie i
        pop {r2, r3}         /* lr goes in r3. r2 now holds tcb pointer. */

        ldr r1, [r2]
        ldr r0, [r1]         /* The first item in pxCurrentTCB is the task top of stack. */
        adds r0, #16         /* Move to the high registers. */
        ldmia r0!, {r4-r7}   /* Pop the high registers. */
        mov r8, r4
        mov r9, r5
        mov r10, r6
        mov r11, r7

        msr psp, r0         /* Remember the new top of stack for the task. */

        subs r0, #32       /* Go back for the low registers that are not automatically 
                             restored. */
        ldmia r0!, {r4-r7} /* Pop low registers.  */

        bx r3  //跳到新的任务地方执行
         ALIGN
}
```

> 参考分析:https://blog.csdn.net/zhoutaopower/article/details/107081495
>
> 参考分析:https://blog.csdn.net/weixin_47730988/article/details/134767306



## 6.vTaskSwitchContext

```c
void vTaskSwitchContext( void )
{
     ...
      /* Select a new task to run using either the generic C or port
         optimised asm code. */
       taskSELECT_HIGHEST_PRIORITY_TASK();
     ...      
}

#define taskSELECT_HIGHEST_PRIORITY_TASK()    
 {                                               
        UBaseType_t uxTopPriority = uxTopReadyPriority; //最高优先级 
                                                        
      /* Find the highest priority queue that contains ready tasks. */  
      while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) ) 
      {                                                                  
           --uxTopPriority;                                              
      }                                                                  
                                                                         
     /* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of   
        the same priority get an equal share of the processor time. */    
     listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) ); 
     uxTopReadyPriority = uxTopPriority;                                         
  } /* taskSELECT_HIGHEST_PRIORITY_TASK */
  
  
#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )  
{              
        /*参数pxList是最高优先级的就绪列表，将就绪列表赋值给pxConstList。*/   
        List_t * const pxConstList = ( pxList );                       
        /* Increment the index to the next item and return the item, ensuring */ 
        /* we don't return the marker used at the end of the list.  */     
                   
        /*判断最高优先级就序列表pxConstList的pxIndex指针是否指向末尾列表项，否则不执行if中内容*/
        ( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;    
      if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )
      {       
          /*假如又触发了一次PendSV中断，此时又需要进行一次任务切换，此时就绪列表的pxIndex指针指    
           *向列表项1，则指向列表项1的下一个末尾列表项。此时的if条件成立，进入程序将就绪列表的 
           *pxIndex指针更换成下一个，还是指向列表项1。以上是当列表中仅有一个任务时。*/
          ( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;
       }
        
        /* 将当前最高优先级任务的所属任务控制块，赋值给pxTCB。*/    
        ( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;  
}
```

![图片描述](https://img.mukewang.com/wiki/660a26b109c4038306812020.jpg)



## 7.任务调度与中断

**PendSV 中断将上下文切换请求延迟到所有其他 中断 处理都已经完成后**，**此时需要将 PendSV 设置为最低优先级**。**若 OS 需要执行上下文切换，他会设置 PendSV 的挂起壮态，并在 PendSV 中断处理函数内执行上下文切换**。如下图所示:

![图片描述](https://img.mukewang.com/wiki/660a26c2096bba2710780476.jpg)



# 五、任务延时



## 1.vTaskDelay



### (1)函数介绍

```c
void vTaskDelay( const TickType_t xTicksToDelay );
参数：
    xTicksToDelay 调用任务应阻塞的 tick 周期数。
    
按给定的 tick 数延迟任务。任务保持阻塞的实际时间取决于 tick 频率。
常量 portTICK_PERIOD_MS 配合 tick 周期分辨率可用于从 tick 频率计算实际时间。
vTaskDelay：至少等待指定个数的Tick Interrupt才能变为就绪状态
```

举例说明:

```c
 void vTaskFunction( void * pvParameters )
 {
     /* Block for 500ms. */
     const TickType_t xDelay = 500 / portTICK_PERIOD_MS;
    
     for( ;; )
     {
         /* Simply toggle the LED every 500ms, blocking between each toggle. */
         vToggleLED();
         vTaskDelay( xDelay );
     }
}

#define portTICK_PERIOD_MS    ( ( TickType_t ) 1000 / configTICK_RATE_HZ )
#define configTICK_RATE_HZ    ((TickType_t)1000)
```



### (2)**实现原理**

```c
void vTaskDelay( const TickType_t xTicksToDelay )
{
     BaseType_t xAlreadyYielded = pdFALSE; // 记录当前任务
 
    /* 如果延时时间为0,则不会将当前任务加入延时列表 */
    if( xTicksToDelay > ( TickType_t ) 0U )
    {
        /*
        这个函数就是比较有意思的，将所有的任务都挂起，其实源码很简单，也很有意思，
        不管三七二十一将调度器锁定，并且这个函数是可以进行嵌套的，说白了挂起所有任务就 
        是挂起任务调度器。调度器被挂起后则不能进行上下文切换，但是中断还是使能的。 
        当调度器被挂起的时候，如果有中断需要进行上下文切换， 那么这个任务将会被挂起，
        在调度器恢复之后才执行切换任务。*/
        vTaskSuspendAll();
        {
            /* 将当前任务从就绪列表中移除,并根据当前系统节拍计数器值计算唤醒时间,然后将任务
               加入延时列表 */
            prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
        }
          
        //恢复任务调度器
        xAlreadyYielded = xTaskResumeAll();
    }
 
    /* 强制执行一次上下文切换*/
    if( xAlreadyYielded == pdFALSE ) // 如果是当前任务，放弃当前任务CPU执行权
    {
        portYIELD_WITHIN_API();
    }
}
```

**static** **volatile** **TickType_t** **xTickCount** = (TickType_t) 0U;

这个变量用来计数，记录系统节拍中断的次数，它在启动调度器时被清零，**在每次系统节拍时钟发生中断之后加1**.相对延时函数会使用到这个变量，**xTickCount表示了当前的系统节拍中断次数**，这个值加上参数规定的延时时间（以系统节拍数表示）xTickToDelay，就是下次唤醒任务的时间，**xTickCount + xTicksToDelay会被记录到任务TCB中，随着任务一起被挂接到延时列表**。

**每次系统节拍时钟中断，中断服务函数都会检查延时列表，查看延时的任务是否到期**，**如果时间到期，则将任务从延时列表中删除，重新加入就绪列表。**



### (3)细节分析

![图片描述](https://img.mukewang.com/wiki/660a26fd09edee2007770530.jpg)

<font color="#fd6f01">**如果执行任务A的过程中发生中断，那么任务A执行的周期就会变长**，**所以使用相对延时函数vTaskDelay()，不能周期的执行任务A。**</font>



## 2.vTaskDelayUntil



### (1)函数介绍

```c
void vTaskDelayUntil( TickType_t *pxPreviousWakeTime,
                      const TickType_t xTimeIncrement );
参数：
pxPreviousWakeTime 指向一个变量的指针，该变量用于保存任务最后一次解除阻塞的时间。 
                   该变量在第一次使用前必须用当前时间进行初始化（见下方示例）。
                   在这之后，该变量 会在 vTaskDelayUntil() 中自动更新。
                   
xTimeIncrement     周期时间段。 该任务将在 （*pxPreviousWakeTime + xTimeIncrement）时间解除阻塞。
                   配合相同的 xTimeIncrement 参数值 调用 vTaskDelayUntil 将导致任务以固定的间隔
                   期执行。                     
                      
```

**举例说明:**

```c
 // Perform an action every 10 ticks.
 void vTaskFunction( void * pvParameters )
 {
     TickType_t xLastWakeTime;
     const TickType_t xFrequency = 10;

     // Initialise the xLastWakeTime variable with the current time.
     xLastWakeTime = xTaskGetTickCount();
     for( ;; )
     {
         // Wait for the next cycle.
         vTaskDelayUntil( &xLastWakeTime, xFrequency );
         // Perform action here.
     }
 }
```



### (2)**实现原理**

```c
BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                            const TickType_t xTimeIncrement )
{
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;

        vTaskSuspendAll();
        {
            /* 保存系统节拍中断次数计数器 */
            const TickType_t xConstTickCount = xTickCount;
 
            /* 计算任务下次唤醒的时间（以系统节拍中断次数表示）. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
            ....
            /* 更新唤醒时间，为下一次调用本函数做准备 */
            *pxPreviousWakeTime = xTimeToWake;
            ....
            if( xShouldDelay != pdFALSE )
            {
                /* 将本任务加入延时列表，注意阻塞时间并不是以当前时间为参考，
                  因此减去了当前系统节拍中断计数器数值*/
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
        
        ....
 
        return xShouldDelay;
    }
```



### (3)细节分析

![图片描述](https://img.mukewang.com/wiki/660a270c0956813f07590592.jpg)

**从调用函数vTaskDelayUntil()开始，`每隔固定周期`，任务B的主体代码就会执行一次**，**即使任务B在执行过程中发生中断，也不会影响这个周期性，只是会缩短其他任务的执行时间**，所以这个函数被称之为绝对延时函数，它可以用于周期性的执行任务B的主体代码。



## 3.对比

`vTaskDelay` 和 `vTaskDelayUntil` 是 FreeRTOS 中用于任务延时的两个函数，它们之间的主要区别在于延时的计算方式和使用场景。

- vTaskDelay
  - **这是一个相对延时函数**。
  - 当调用 `vTaskDelay` 时，它会阻塞当前任务，直到指定的延时时间（以系统时钟节拍为单位）结束后，任务才会被重新调度执行。
  - `v`**`TaskDelay`** **的延时时间是从调用该函数后开始计算的**。例如，如果你调用 `vTaskDelay(100)`，那么从调用这个函数开始，任务将被阻塞100个系统时钟节拍周期后才会解除阻塞。
  - **这种延时方式不适用于需要周期性执行任务的场合，因为它不考虑实际时间，只考虑经过的节拍数**。
- vTaskDelayUntil
  - **这是一个绝对延时函数****。**
  - 它基于实际的时间点来解除任务的阻塞，而不是基于经过的时间长度。
  - `vTaskDelayUntil` 需要传入一个指向 `TickType_t` 类型的变量的指针，该变量记录了任务上次被唤醒的时间点。每次调用这个函数时，都会更新这个时间点。
  - 该函数的第二个参数 `xTimeIncrement` 指定了任务的唤醒周期。例如，如果你使用 `vTaskDelayUntil` 并设置 `xTimeIncrement` 为1000（假设1 tick = 1ms），那么任务将在每个秒的整点时刻被唤醒。
  - **这种延时方式适用于需要周期性执行的任务，因为它确保任务在固定的时间点被唤醒，从而实现周期性执行**。

总结来说，**`vTaskDelay`** **适合于需要在某个时间点之后执行任务的场景**，**而** **`vTaskDelayUntil`** **适合于需要在固定时间间隔内周期性执行任务的场景**。在使用这两个函数时，需要考虑任务的优先级、调度策略以及系统时钟的精度等因素，以确保系统的稳定运行和延时操作的准确性。